= Stargate GraphQL API QuickStart

*Time to complete: 5 minutes*

Stargate is a data gateway deployed between client applications and a database.
In this QuickStart, you'll be up and running on your local machine with the
GraphQL API plugin that exposes CRUD access to data stored in Cassandra tables.

// tag::prereqsList[]
include::partial$text/prereqs.adoc[]
// end::prereqsList[]

// tag::getDockerImage[]
include::partial$bash/docker_pull.sh[]
// end::getDockerImage[]

// tag::startDocker[]
include::partial$bash/docker_run.sh[]
// end::startDocker[]

== Using the Stargate GraphQL API

In order to use the Stargate GraphQL API, an authorization token must be generated
to access the interface. A REST API token is used for this purpose.

// tag::startGenAuthToken[]
include::partial$bash/gen_auth_token.sh[]
// tag::endGenAuthToken[]

You will need to add this token to the GraphQL Playground in order to authorize
your GraphQL requests. Copy the value after `"authToken"` to use later.

// tag:startUsingGraphqlPlayground[]
== Using the GraphQL Playground

The easiest way to get started is to use the built-in GraphQL playground that is
included in the `stargate` docker container. It can be accessed at
http://localhost:8080/playground[http://localhost:8080/playground] using a local
browser after the docker container is started.

Once in the playground, you can create new schema and interact with the
GraphQL APIs. The server paths are structured to provide access to creating and
querying schema, as well as querying and modifying Cassandra data:

* `/graphql-schema`
** An API for exploring and creating schema, or Data Definition Language (DDL).
For example, Cassandra has queries to create, modify, drop keyspaces and tables,
such as `CREATE KEYSPACE`, `CREATE TABLE1`, or `DROP TABLE`.
* `/graphql/<keyspace>`
** An API for querying and modifying your Cassandra tables using GraphQL fields.

We'll start the playground with `/graphql-schema` to create some schema.
// tag:endUsingGraphqlPlayground[]

== Creating schema

// tag::startCreateKS[]
=== Creating a keyspace

Before you can start using the GraphQL API, you must first create a Cassandra
keyspace and at least one table in your database. If you are connecting to a
Cassandra database with existing schema, you can skip this step.

Inside the GraphQL playground, navigate to
http://localhost:8080/graphql-schema[http://localhost:8080/graphql-schema]
and create a keyspace by executing the following mutation:

[source, plaintext]
----
include::quickstart:partial$graphql/createKeyspace.graphql[]
----
For each keyspace created in your Cassandra schema, a new path is created under
the `graphql-path` root (default is: `/graphql`). For example, the mutation just
executed creates a path `/graphql/library` for the `library` keyspace when
Cassandra creates the keyspace.

Add the auth token to the HTTP Headers box in the lower lefthand corner:

[source, plaintext]
----
{
  "x-cassandra-token":"bff43799-4682-4375-99e8-23c8a9d0f304"
}
----

[IMPORTANT]
====
Notice that the key for this JSON token is different than the value that the
generate token has. It is `x-cassandra-token`, not `auth-token`.
====

Now run the mutation to create the keyspace. You should see a return value of:

[source, plaintext]
----
{
  "data": {
    "createKeyspace": true
  }
}
----
// tag::endCreateKS[]

// tag::startCreateTables[]
=== Creating a table

After the keyspace exists, you can create two tables by executing the following
mutation:

[source,plaintext]
----
mutation {
  books: createTable(
    keyspaceName:"library",
    tableName:"books",
    partitionKeys: [ # The keys required to access your data
      { name: "title", type: {basic: TEXT} }
    ]
    values: [ # The values associated with the keys
      { name: "author", type: {basic: TEXT} }
    ]
  )
  authors: createTable(
    keyspaceName:"library",
    tableName:"authors",
    partitionKeys: [
      { name: "name", type: {basic: TEXT} }
    ]
    clusteringKeys: [ # Secondary key used to access values within the partition
      { name: "title", type: {basic: TEXT}, order: "ASC" }
  	]
  )
}
----

returns

[source, plaintext]
----
{
  "data": {
    "books": true,
    "authors": true
  }
}
----

Worth noting is that one mutation is used to create two tables. Information about
partition keys and clustering keys are found in the
https://cassandra.apache.org/doc/latest/cql/[CQL reference].
// tag::endCreateTables[]

// tag::startCheckKSTables[]

=== Checking that keyspaces and tables exist

To check if a keyspace or tables exist, GraphQL queries can be executed:

[source, plaintext]
----
query GetKeyspace {
  keyspace(name: "library") {
      name
      dcs {
          name
          replicas
      }
      tables {
          name
          columns {
              name
              kind
              type {
                  basic
                  info {
                      name
                  }
              }
          }
      }
  }
}
query GetTables {
  keyspace(name: "library") {
      name
      tables {
          name
          columns {
              name
              kind
              type {
                  basic
                  info {
                      name
                  }
              }
          }
      }
  }
}
----
Because these queries are named, the GraphQL playground will allow you to select
which query to run. The first query will return information about the keyspace
`library` and the tables within it. The second query will return just information
about the tables in that keyspace.
// tag::startCheckKSTables[]

== Interacting with tables

// tag::startAPIGeneration[]
=== API generation

Once schema is created, the GraphQL API generates mutations and queries can be
used. In the GraphQL playground, expand the tabs on the righthand side labelled
"DOCS" or "SCHEMA", to discover the items available and the syntax to use.

For each table in the Cassandra schema that we just created, several GraphQL
fields are created for
handling queries and mutations. For example, the GraphQL API generated for the
`books` table is:

[source, plaintext]
----
schema {
  query: Query
  mutation: Mutation
}

type Query {
  books(value: BooksInput, filter: BooksFilterInput, orderBy: [BooksOrder], options: QueryOptions): BooksResult
  booksFilter(filter: BooksFilterInput!, orderBy: [BooksOrder], options: QueryOptions): BooksResult
}

type Mutation {
  insertBooks(value: BooksInput!, ifNotExists: Boolean, options: UpdateOptions): BooksMutationResult
  updateBooks(value: BooksInput!, ifExists: Boolean, ifCondition: BooksFilterInput, options: UpdateOptions): BooksMutationResult
  deleteBooks(value: BooksInput!, ifExists: Boolean, ifCondition: BooksFilterInput, options: UpdateOptions): BooksMutationResult
}
----

The query `books()` can query book values by equality. If no value argument is
provided, then the first hundred (default pagesize) values are returned.

Several mutations are created that you can use to insert, update, or delete books.
Some important facts about these mutations are:

* `insertBooks()` is an **upsert** operation if a book with the same information
exist, unless the `ifNotExists` is set to true.
* `updateBooks()` is also an **upsert** operation, and will create a new book if
it doesn't exist, unless `ifNotExists` is set to true.
* Using the `ifNotExists` or `ifCondition` options affects the performance of
operations because of the compare-and-set execution path in Cassandra. Under
the hood these operations are using a feature in Cassandra called lightweight
transactions (LWTs).

As more tables are added to a keyspace, additional GraphQL fields will add
query and mutation types that can be used to interact with the table data.
// tag::endAPIGeneration[]

// tag::startWriteData[]
=== Write data

Any of the created APIs can be used to interact with the GraphQL data, to write
or read data.

First, let's navigate to your new keyspace `library` inside the playground.
Change the location to
http://localhost:8080/graphql/library[http://localhost:8080/graphql/library]
and add a couple of books to the `book` table:

[source,plaintext]
----
mutation {
  moby: insertBooks(value: {title:"Moby Dick", author:"Herman Melville"}) {
    value {
      title
    }
  }
  catch22: insertBooks(value: {title:"Catch-22", author:"Joseph Heller"}) {
    value {
      title
    }
  }
}
----

returns

[source, plaintext]
----
{
  "data": {
    "moby": {
      "value": {
        "title": "Moby Dick"
      }
    },
    "catch22": {
      "value": {
        "title": "Catch-22"
      }
    }
  }
}
----

If we want to read all the data for a book, we can use a query.
// tag::endWriteData[]

// tag::startReadData[]
=== Read data

The following query, looking at the location
http://localhost:8080/graphql/library[http://localhost:8080/graphql/library]
will get both the `title` and the `author` for the specified book:

[source,plaintext]
----
query oneBook {
    books (value: {title:"Moby Dick"}) {
      values {
      	title
      	author
      }
    }
}
----

returns

[source,plaintext]
----
{
  "data": {
    "books": {
      "values": [
        {
          "title": "Moby Dick",
          "author": "Herman Melville"
        }
      ]
    }
  }
}
----
// tag::endReadData[]

// tag::startUpdateData[]
=== Update data

Using the column that we added earlier, the data for a book is updated with the
ISBN value:

[source,plaintext]
----
mutation updateABook {
  moby: updateBooks(value: {title:"Moby Dick", author:"Herman Melville", isbn: "9780140861723"}, ifExists: true ) {
    value {
      title
      author
      isbn
    }
  }
}
----

NOTE: Updates are upserts. If the row doesn't exist, it will be created.
If it does exist, it will be updated with the new row data.

// tag::endUpdateData[]

// tag::startDeleteData[]
=== Delete data

After adding the book "Pride and Prejudice" with an `insertBooks()`, I can delete
the book using `deleteBooks()` to illustrate deleting data:

////
The insertion is:
mutation insertAnotherBook {
  PaP: insertBooks(value: {title:"Pride and Prejudice", author:"Jane Austen"}) {
    value {
      title
    }
  }
}
////

[source,plaintext]
----
mutation deleteABook {
  PaP: deleteBooks(value: {title:"Pride and Prejudice"}, ifExists: true ) {
    value {
      title
    }
  }
}
----
// tag::endDeleteData[]

For more information on the GraphQL API, see xref:developers-guide/graphql-using.adoc[Using the GraphQL API] in the Data API section.
