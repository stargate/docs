= Apollo data federation for GraphQL schema-First



FROM NETFLIX:
The goal of GraphQL Federation is two-fold: provide a unified API for consumers
while also giving backend developers flexibility and service isolation.
To achieve this, schemas need to be created and annotated to indicate how
ownership is distributed.
Let’s look at an example with three core entities:
Movie: At Netflix, we make titles (shows, films, shorts etc.).
For simplicity, let’s assume each title is a Movie object.
Production: Each Movie is associated with a Studio Production.
A Production object tracks everything needed to make a Movie including shooting location, vendors, and more.
Talent: the people working on a Movie are the Talent, including actors, directors, and so on.
These three domains are owned by three separate engineering teams responsible for
their own data sources, business logic, and corresponding microservices.
In an unfederated implementation, we would have this simple Schema and Resolvers
owned and implemented by the Studio API team.
The GraphQL Framework would take in queries from clients and orchestrate the
calls to the resolvers in a breadth-first traversal.

SEE DIAGRAM

This ability to extend a Movie type across GraphQL service boundaries makes Movie
a Federated Type.
Resolving a given field requires delegation by a gateway layer down to the
owning domain services.


****
CQL indexes can be created on regular (not partition key nor clustering columns) fields.
Parameters
Queries are parameterized by:
partition key and clustering fields
regular fields, if they are indexed

Stargate only allows combinations of fields that won't require an ALLOW FILTERING
at the CQL level:
- at most one indexed field can be present in the signature. If so, it must
either be the only parameter, or the other parameters must cover the full
partition key (no clustering columns are allowed).
- if no indexed field is present, then all partition key fields must be present,
but it's possible to omit some or all of the clustering fields (in which case
  the query will return multiple rows).

The arguments must have the same names and types as the fields on the object type.
They don't necessarily have to be in order (although it's probably the most
logical to keep the same order).
****

For the Library example:

*** 1-4 are NOT POSSIBLE ***
1. (allBooks) Get all books. _Book_
2. (allReaders) Get all readers. _Reader_
3. (allOrders) Get all checkout orders. _Order_
4. (allLibColls) Get all lib collections. _LibCollection_

5. (booksByTitle) Look up books by title (partition key). _Book_
6. (bookIByIsbn) Look up a book by ISBN (clustering column). _BookI_
7. (booksByTitleAndIsbn) Look up a book by title and ISBN (primary key). _Book_
8. (booksByAuthor) Look up books by author (non-PK column collection, index). _Book_
9. (booksByTitleAndAuthor) Look up a book by title and author (partition key + index). _Book_

10. (readerByName) Look up a reader by name (partition key). _Reader_
11. (readerUByUserid) Look up a reader by user_id (clustering column). _ReaderU_
12. (readerByNameAndUserid) Look up a reader by name and user_id (primary key). _Reader_
    All 3 of these queries will allow you to get all the books reviewed by a reader.

13. (orders) Get all orders. _Order_
13a. (order) Get order by checkout_id. _Order_
13b. (orderById) Look up an order by checkout_id (partition key). _Order_
    This will give you all books in the order.

14. CAN'T DO?(libCollByType) Look up a library collection by type (partition key, partial primary key). _LibCollection_
15. CAN'T DO(libCollByLibid) Look up a library collection by lib_id (partition key, partial primary key). _LibCollection_
16. (libCollByTypeAndLibid) Look up a library collection by type and lib_id (primary key). _LibCollection_
17. (libCollByName) Look up a library collection by name (non-PK column, index). _LibCollection_

20.(reviewsByBook) Look up a book and find all reviews and return review+book info. _union_ of _Book_ and _Reader_
    Find a book, check all readers for a review of the book by Review.bookTitle.
21. (orderByBook) Look up a book and find all the readers who have checked it out. _union_ of _Book_ and _Order_
    Find a book, look up the orders, get the readers.
22. THIS IS readerCONTAINS(fullReview) For a reader's review, get all the book information (non-PK column collection, index)
Requires all review information. _Reader_
23. (??) Look at a reader and get all books read. _union_ of _Book_ and _Reader_
