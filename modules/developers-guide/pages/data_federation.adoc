= Apollo data federation for GraphQL schema-First

Data federation is the creation of a virtual database that aggregates data from
distributed sources, giving them a common data model.
It is an approach to data integration that provides a single source of data for
front-end applications.

To get the most out of GraphQL, your organization should expose a single data
graph that provides a unified interface for querying any combination of your
backing data sources.
However, it can be challenging to represent an enterprise-scale data graph with
a single, monolithic GraphQL server.

To remedy this, you can divide your graph's implementation across multiple
composable services with Apollo Federation.
Unlike other distributed GraphQL architectures (such as schema stitching),
Apollo Federation uses a declarative programming model that enables each subgraph
to implement only the part of your composed supergraph that it's responsible for.

An Apollo Federation architecture consists of:

* A collection of subgraphs (usually represented by different back-end services)
that each define a distinct GraphQL schema
* A gateway that composes the subgraphs into a federated data graph and executes
queries across multiple subgraphs

FROM NETFLIX:
The goal of GraphQL Federation is two-fold: provide a unified API for consumers
while also giving backend developers flexibility and service isolation.
To achieve this, schemas need to be created and annotated to indicate how
ownership is distributed.
Let’s look at an example with three core entities:
Movie: At Netflix, we make titles (shows, films, shorts etc.).
For simplicity, let’s assume each title is a Movie object.
Production: Each Movie is associated with a Studio Production.
A Production object tracks everything needed to make a Movie including shooting location, vendors, and more.
Talent: the people working on a Movie are the Talent, including actors, directors, and so on.
These three domains are owned by three separate engineering teams responsible for
their own data sources, business logic, and corresponding microservices.
In an unfederated implementation, we would have this simple Schema and Resolvers
owned and implemented by the Studio API team.
The GraphQL Framework would take in queries from clients and orchestrate the
calls to the resolvers in a breadth-first traversal.

SEE DIAGRAM

This ability to extend a Movie type across GraphQL service boundaries makes Movie
a Federated Type.
Resolving a given field requires delegation by a gateway layer down to the
owning domain services.

NOTE:
ONLY PRIMARY KEY FIELDS can be used in @key. In stargate schema, you can use
just `@key` without specifying the `fields`, because the PK is inferred.

****
CQL indexes can be created on regular (not partition key nor clustering columns) fields.
Parameters
Queries are parameterized by:
partition key and clustering fields
regular fields, if they are indexed

Stargate only allows combinations of fields that won't require an ALLOW FILTERING
at the CQL level:
- at most one indexed field can be present in the signature. If so, it must
either be the only parameter, or the other parameters must cover the full
partition key (no clustering columns are allowed).
- if no indexed field is present, then all partition key fields must be present,
but it's possible to omit some or all of the clustering fields (in which case
  the query will return multiple rows).

The arguments must have the same names and types as the fields on the object type.
They don't necessarily have to be in order (although it's probably the most
logical to keep the same order).
****

For the Library example:

*** 1-4 are NOT POSSIBLE ***
1. (allBooks) Get all books. _Book_
2. (allReaders) Get all readers. _Reader_
3. (allOrders) Get all checkout orders. _Order_
4. (allLibColls) Get all lib collections. _LibCollection_

5. (booksByTitle) Look up books by title (partition key). _Book_
6. (bookIByIsbn) Look up a book by ISBN (clustering column). _BookI_
7. (booksByTitleAndIsbn) Look up a book by title and ISBN (primary key). _Book_
8. (booksByAuthor) Look up books by author (non-PK column collection, index). _Book_
9. (booksByTitleAndAuthor) Look up a book by title and author (partition key + index). _Book_

10. (readerByName) Look up a reader by name (partition key). _Reader_
11. (readerUByUserid) Look up a reader by user_id (clustering column). _ReaderU_
12. (readerByNameAndUserid) Look up a reader by name and user_id (primary key). _Reader_
    All 3 of these queries will allow you to get all the books reviewed by a reader.

13. (orderById) Look up an order by checkout_id (partition key). _Order_
    This will give you all books in the order.

14. CAN'T DO?(libCollByType) Look up a library collection by type (partition key, partial primary key). _LibCollection_
15. CAN'T DO(libCollByLibid) Look up a library collection by lib_id (partition key, partial primary key). _LibCollection_
16. (libCollByTypeAndLibid) Look up a library collection by type and lib_id (primary key). _LibCollection_
17. (libCollByName) Look up a library collection by name (non-PK column, index). _LibCollection_

18. (orders) Get all orders. _Order_
19. (order) Get order by checkout_id. _Order_

20.(reviewsByBook) Look up a book and find all reviews and return review+book info. _union_ of _Book_ and _Reader_
    Find a book, check all readers for a review of the book by Review.bookTitle.
21. (orderByBook) Look up a book and find all the readers who have checked it out. _union_ of _Book_ and _Order_
    Find a book, look up the orders, get the readers.
22. (fullReview) For a reader's review, get all the book information (non-PK column collection, index). _union_ of _Book_ and _Reader_
