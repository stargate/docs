= Using the Stargate Document API

Stargate is a data gateway deployed between client applications and a database.
The Document API plugin that exposes CRUD access to data stored as JSON
documents in collections.

// tag::prereqsList[]
include::quickstart:partial$text/prereqs.adoc[]
// end::prereqsList[]

// tag::getDockerImage[]
include::quickstart:partial$bash/docker_pull.sh[]
// end::getDockerImage[]

// tag::startDocker[]
include::quickstart:partial$bash/docker_run.sh[]
// end::startDocker[]

== Using the Auth API to generate an auth token

// tag::GenAuthToken[]
In order to use the Stargate Document API, an authorization token must be
generated to access the interface.

include::quickstart:partial$bash/gen_auth_token.sh[]
// end::GenAuthToken[]

// tag::UseAuthToken[]
=== Use the auth token
Store the auth token in an environment variable to make it easy to use with `cURL`.

[source,bash]
----
export AUTH_TOKEN={auth-token}
----
// end::UseAuthToken[]

// tag::UsingPostman[]
== Using Postman

If you prefer, you can use Postman as a client interface for exploring REST APIs
(https://www.postman.com/downloads/[download here]).
We've provided a
// LLP: NEED TO CREATE THIS FILE!!
https://github.com/stargate/docs/blob/master/modules/developers-guide/examples/stargate-document-api.postman_collection.json[Stargate Document API Postman Collection] that you
can import in Postman to play with the examples shown in this walkthrough.

Now you're ready to use the Document API for CRUD operations.
// end::UsingPostman[]

== Creating or dropping schema

In order to use the Document API, you must create schema that defines the namespace
that will store the data. A namespace is a container for which a
`replication factor` defines the number of data replicas the database will store.

Namespaces contain collections that consist of unstructured JSON documents.
Documents can themselves hold multiple documents. Multiple collections are contained
in a namespace, but a collection cannot be contained in multiple namespaces.

Only namespaces need schema created. Collections are specified when a document
is inserted.

// tag::CreateNS[]
=== Creating a namespace

Before you can start using the Document API, you must first create a
namespace to hold collections of documents in your database.

// LLP: IS THIS TRUE?
If you are connecting to a
Cassandra database with existing schema, you can skip this step.

// LLP:   need to change this to something that is better. Need to take this out and
// put it in Auth API and call there.
Note that you must create an xref:document-using.adoc#GenAuthToken[auth token] first.

Send a `POST` request to `/v2/schemas/namespaces`.
In this example we use `myworld` for the `name`,
and `1` for the number of data `replicas`.

[source,bash]
----
curl --location --request POST 'localhost:8082/v2/schemas/namespaces' \
--header "X-Cassandra-Token: $AUTH_TOKEN" \
--header 'Content-Type: application/json' \
--data '{
    "name": "myworld",
    "replicas": 1
}'
----
// end::CreateNS[]

// tag::CheckNS[]
=== Checking namespace existence

To check if a namespace or collection exists, execute a
Document API query with `cURL`:

For namespaces:

[source,bash]
----
curl -L -X GET 'localhost:8082/v2/schemas/namespaces' \
--header 'accept: application/json' \
--header 'content-type: application/json' \
--header "X-Cassandra-Token: $AUTH_TOKEN"
----

returns

[source, plaintext]
----
{"data":[{"name":"system_distributed"},{"name":"system"},{"name":"data_endpoint_auth"},{"name":"users_keyspace"},{"name":"system_schema"},{"name":"myworld"},{"name":"stargate_system"},{"name":"system_auth"},{"name":"system_traces"}]}
----

To get a particular namespace:

[source,bash]
----
curl -L -X GET 'localhost:8082/v2/schemas/namespaces/myworld' \
--header 'accept: application/json' \
--header 'content-type: application/json' \
--header "X-Cassandra-Token: $AUTH_TOKEN"
----

returns

[source, plaintext]
----
{"data":{"name":"myworld"}}
----
// end::CheckNS[]

//== Drop namespaces or collections

// tag::deleteNS[]
=== Dropping a namespace

Send a `DELETE` request to `/v2/schemas/namespaces/{namespace_name}` to delete
a namespace. All data and all collection schema will be deleted along with the
namespace schema.

[source, bash]
----
curl --location \
--request DELETE 'localhost:8082/v2/schemas/namespaces/myworld' \
--header "X-Cassandra-Token: $AUTH_TOKEN" \
--header 'Content-Type: application/json'
----
// end::deleteNS[]

// LLP: leaving this item in, in anticipation of the addition to the API
// tag::deleteColl[]
//=== Dropping a collection

//Send a `DELETE` request to `/v2/schemas/namespaces/{namespace_name}/collections/{collection_name}`
//to delete a collection. All data will be deleted along with the collection schema.

//[source, bash]
//----
//curl --location \
//--request DELETE 'localhost:8082/v2/schemas/namespaces/myworld/collections/fitness' \
//--header "X-Cassandra-Token: $AUTH_TOKEN" \
//--header 'Content-Type: application/json'
//----
// end::deleteColl[]

// tag:updateColl[]
//== Update or replace a collection

//If you find a collection must be updated or replaced, send a `PUT` request to
//`/v2/schemas/namespaces/{namespace_name}/collections/{collection_name}` with
//the information to change:

//[source, bash]
//----
//curl --location
//--request PUT 'localhost:8082/v2/schemas/namespaces/myworld/collections/fitness'
//--header "X-Cassandra-Token: $AUTH_TOKEN"
//--header 'Content-Type: application/json'
// LLP: PUT IN INFO HERE???
//----
// end:updateColl[]

== Interacting with data stored in collections

// tag::WriteData[]
=== Write data

First, let's add a document to a specified collection.
Send a `POST` request to `/v2/namespaces/{namespace_name}/collections/{collections_name}`
to add data to the collection.
The data is passed in the JSON body.

[source,bash]
----
curl --location --request POST 'localhost:8082/v2/namespaces/myworld/collections/fitness' \
--header "X-Cassandra-Token: $AUTH_TOKEN" \
--header 'Content-Type: application/json' \
--data '{
    "firstname": "Janet",
    "lastname": "Doe",
    "email": "janet.doe@gmail.com",
    "favorite color": "grey"
}'
----

returns

[source,plaintext]
----
{"documentId":"1c338f67-4bff-443d-b2d2-f21d8291bdb8"}
----

Notice that the `document-id` returned is a UUID if not specified.

Next, let's add a document to a specified collection, but specify the `document-id`.
Send a `PUT` request to
`/v2/namespaces/{namespace_name}/collections/{collections_name}/{document-id}`
to add data to the collection.
The `document-id` can be any string.
The data is passed in the JSON body.

[source,bash]
----
curl --location \
--request PUT 'localhost:8082/v2/namespaces/myworld/collections/fitness/some-stuff' \
--header "X-Cassandra-Token: $AUTH_TOKEN" \
--header 'Content-Type: application/json' \
--data '{
    "id": "Some stuff",
    "thestuff": "This is a nonsensical message."
}'
----

returns

[source,plaintext]
----
{"documentId":"some-stuff"}
----

Note the difference between using `POST` and `PUT`. `POST` is used to insert
documents to an empty collection. `PUT` is used to add a document to an existing
collection.

You can also insert documents that have nested values, or sub-documents.
Send a `PUT` request to
`/v2/namespaces/{namespace_name}/collections/{collections_name}/{document-id}`
to add data to the collection.
The data is passed in the JSON body.

[source,bash]
----
curl --location \
--request PUT 'localhost:8082/v2/namespaces/myworld/collections/fitness/350041bd-5e41-421b-9b3b-f021921851ce' \
--header "X-Cassandra-Token: $AUTH_TOKEN" \
--header 'Content-Type: application/json' \
--data '{
    "firstname": "Joey",
    "lastname": "Doe",
    "weights": {
      "type": "bench press",
      "weight": 150,
      "reps": 15
  }
}'
----

returns

[source, plaintext]
----
{"documentId":"350041bd-5e41-421b-9b3b-f021921851ce"}
----


// LLP: NEED PUT/PATCH sub-document by path
// end::WriteData[]


////
==== Data types???
Need to add data types!!
////

// tag::ReadData[]
=== Read data

Let's check that the data was inserted. Send a `GET` request to
`/v2/namespaces/{namespace_name}/collections/{collections_name}` to retrieve
all the documents:

[source,bash]
----
curl GET \
--location 'http://localhost:8082/v2/namespaces/myworld/collections/fitness?page-size=3' \
--header "X-Cassandra-Token: $AUTH_TOKEN" \
--header 'Content-Type: application/json' \
----

returns

[source, plaintext]
----
{"data":
{
  "some-stuff":{"id":"Some stuff","thestuff":"This is a nonsensical message."},
"1c338f67-4bff-443d-b2d2-f21d8291bdb8":{"email":"janet.doe@gmail.com","favorite color":"grey","firstname":"Janet","lastname":"Doe"},
"350041bd-5e41-421b-9b3b-f021921851ce":{"firstname":"Joey","lastname":"Doe","weights":{"reps":15,"type":"bench press","weight":150}},
"pageState":"JDAyMGE0MGU5LTFiYjctNGUwNS05YmRlLTcyYzg4Y2U1NzExYxv/VVVVVVVVVVQIbGFzdG5hbWX/VVVVVVVVVVXwf///6fB////6"
}
----

The `page-size` parameter is included to get all the documents, rather than the last inserted document.


Let's check that the data was inserted. Send a `GET` request to
`/v2/namespaces/{namespace_name}/collections/{collections_name}/{docment-id}` to
retrieve the document:
[source, bash]
----
curl --location --request  GET 'localhost:8082/v2/namespaces/myworld/collections/fitness/020a40e9-1bb7-4e05-9bde-72c88ce5711c' \
--header "X-Cassandra-Token: $AUTH_TOKEN" \
--header 'accept: application/json' \
--header 'content-type: application/json'
----

returns

[source, plaintext]
----
{"documentId":"020a40e9-1bb7-4e05-9bde-72c88ce5711c","data":{"email":"janet.doe@gmail.com","favorite color":"grey","firstname":"Janet","lastname":"Doe"}}
----

Now let's search for a particular document using a `where` clause.
Send a `GET` request to
`/v2/namespaces/{namespace_name}/collections/{collections_name}/{document-id}`
to retrieve the document for `Janet`:

// LLP: FIX THIS!!
[source, bash]
----
curl -X --location --request GET 'localhost:8082/v2/namespaces/myworld/collections/fitness' \
--header "X-Cassandra-Token: $AUTH_TOKEN" \
--header 'Content-Type: application/json' \
--header 'accept: application/json' \
--data-urlencode 'where={
        "firstname": "Janet"
      }'
----

returns

[source, plaintext]
----
{"data":{"1c338f67-4bff-443d-b2d2-f21d8291bdb8":{"email":"janet.doe@gmail.com","favorite color":"grey","firstname":"Janet","lastname":"Doe"}},"pageState":"JDFjMzM4ZjY3LTRiZmYtNDQzZC1iMmQyLWYyMWQ4MjkxYmRiOBv/VVVVVVVVVVQIbGFzdG5hbWX/VVVVVVVVVVXwf///+vB////6"}
----

The `pageState` is useful for pagination of the results in queries.
// end::ReadData[]

// tag::UpdateData[]
=== Update data

Data changes, so often it is necessary to update an entire document.
To update a document, send a `PUT` request to
`/v2/namespaces/{namespace_name}/collections/{collections_name}`.

[source,bash]
----
curl PUT \
--location 'http://localhost:8082/v2/namespaces/myworld/collections/fitness' \
--header "X-Cassandra-Token: $AUTH_TOKEN" \
--header 'Content-Type: application/json' \
--data-urlencode '{
  "data": {
    "documentId": "my-first-lift01012020",
    "type": "weightlifting",
    "lift": {
      "name": "bench press",
      "reps": 12,
      "weight": 150
    }
  }
}'
----

NOTE: Updates are upserts. If the document doesn't exist, it will be created.
If it does exist, it will be updated with the new document data.

// end::UpdateData[]

It is also possible to update only part of a document. To partially update, send
a `PATCH` request to
 `/v2/namespaces/{namespace_name}/collections/{collections_name}/{document-id}`.
In this example, we realize we should not have changed the weight, and
we want to only change that one item:

[source,bash]
----
curl PATCH \
--location 'http://localhost:8082/v2/namespaces/myworld/collections/fitness' \
--header "X-Cassandra-Token: $AUTH_TOKEN" \
--header 'Content-Type: application/json' \
--data-urlencode '{
  "data": {
    "documentId": "my-first-lift01012020",
    "type": "weightlifting",
    "lift": {
      "name": "bench press",
      "reps": 12,
      "weight": 150
    }
  }
}'
----

// tag::DeleteData[]
=== Delete data
To delete a document, send a `DELETE` request to
`/v2/namespaces/{namespace_name}/collections/{collections_name}/{document-id}`.

[source,bash]
----
curl DELETE \
--location 'http://localhost:8082/v2/namespaces/myworld/collections/fitness/my-first-lift01012020' \
--header "X-Cassandra-Token: $AUTH_TOKEN" \
--header 'Content-Type: application/json' \
----
// end::DeleteData[]
