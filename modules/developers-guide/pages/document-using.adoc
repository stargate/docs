= Using the Stargate Document API
:docid : 3ffc7ae6-c42d-46de-b52b-b5e77ae6a87b
Stargate is a data gateway deployed between client applications and a database.
The Document API plugin that exposes CRUD access to data stored as unstructured JSON
documents in collections.

// tag::prereqsList[]
include::quickstart:partial$text/prereqs.adoc[]
// end::prereqsList[]

// tag::getDockerImage[]
include::quickstart:partial$bash/docker_pull.sh[]
// end::getDockerImage[]

// tag::startDocker[]
include::quickstart:partial$bash/docker_run.sh[]
// end::startDocker[]

// tag::swaggerUI[]
=== Swagger UI for the Document API

Once you have started the docker container, you can access the Document API
in a browser at `localhost:8082/swagger-ui`.
// end::swaggerUI[]


== Using the Auth API to generate an auth token

// tag::GenAuthToken[]
In order to use the Stargate Document API, an authorization token must be
generated to access the interface.

include::quickstart:partial$bash/gen_auth_token.sh[]
// end::GenAuthToken[]

// tag::UseAuthToken[]
include::quickstart:partial$bash/use_auth_token_rest_document.sh[]
// end::UseAuthToken[]

// tag::UsingPostman[]
== Using Postman

If you prefer, you can use Postman as a client interface for exploring the Document API
(https://www.postman.com/downloads/[download here]). You will need to add the
auth token to the header, similar to the `X-Cassandra-Token` shown below.
// LLP: NEED TO CREATE THIS FILE!!
//We've provided a
//https://github.com/stargate/docs/blob/master/modules/developers-guide/examples/stargate-document-api.postman_collection.json[Stargate Document API Postman Collection] that you
//can import in Postman to play with the examples shown in this walkthrough.
// end::UsingPostman[]

Now you're ready to use the Document API for CRUD operations.

// tag::CreateNS[]
== Creating or dropping a namespace

In order to use the Document API, you must create the namespace as a container
that will store collections, which in turn store documents.
Documents can themselves hold multiple documents.
Multiple collections are contained in a namespace, but a collection cannot be
contained in multiple namespaces.

Only namespaces need to specifically created. Collections are specified when a document
is inserted. A optional setting, `replicas`, defines
the number of data replicas the database will store for the namespace.
If no replica is defined, then for a namespace in a single datacenter cluster,
the default is 1, and for a multiple-datacenter cluster, the default is 3 for each
datacenter.

=== Creating a namespace

==== Simple namespace

Send a `POST` request to `/v2/schemas/namespaces`.
In this example we use `myworld` for the `name`, and no `replicas` setting, to default to 1.

[source,bash]
----
curl --location --request POST 'localhost:8082/v2/schemas/namespaces' \
--header "X-Cassandra-Token: $AUTH_TOKEN" \
--header 'Content-Type: application/json' \
--data '{
    "name": "myworld"
}'
----

The authorization token and the content type are passed with  `--header`. The
token must be identified as `X-Cassandra-Token` so that cluster recognizes the token
and its value.
The specified name and replicas for the namespace are passed as JSON
data using `--data`.
// end::CreateNS[]

// tag::CreateNSextra[]
==== Set replicas in simple namespace

To set the replicas, send a `POST` request to `/v2/schemas/namespaces`.
In this example we use `myworld` for the `name`,
and `2` for the number of data `replicas`.

[source,bash]
----
curl --location --request POST 'localhost:8082/v2/schemas/namespaces' \
--header "X-Cassandra-Token: $AUTH_TOKEN" \
--header 'Content-Type: application/json' \
--data '{
    "name": "myworld",
    "replicas": 2
}'
----

==== Namespace for multiple datacenters

For a multiple-datacenter cluster, a namespace is defined `datacenters`.
Send a `POST` request to `/v2/schemas/namespaces`.
In this example we use `myworld-dcs` for the `name`, the datacenters are `dc1` and `dc2`,
where `dc1` defaults to 3 replicas and `dc2` is set to 5 replicas.

[source,bash]
----
curl --location --request POST 'localhost:8082/v2/schemas/namespaces' \
--header "X-Cassandra-Token: $AUTH_TOKEN" \
--header 'Content-Type: application/json' \
--data '{
    "name": "myworld-dcs",
    "datacenters": [ {"name": "dc1"}, {"name": "dc2", "replicas": 5} ]
}'
----
// end::CreateNSextra[]

// tag::CheckNS[]
=== Checking namespace existence

To check if a namespaces exist, execute a
Document API query with `cURL` to find all the namespaces:

[source,bash]
----
curl -L -X GET 'localhost:8082/v2/schemas/namespaces' \
--header "X-Cassandra-Token: $AUTH_TOKEN" \
--header 'Content-Type: application/json'
----

returns:

[source, plaintext]
----
{"data":[{"name":"system_distributed"},{"name":"system"},
{"name":"data_endpoint_auth"},{"name":"system_schema"},{"name":"myworld"},
{"name":"stargate_system"},{"name":"system_auth"},{"name":"system_traces"}]}
----

To get a particular namespace, specify the namespace in the URL:

[source,bash]
----
curl -X GET 'localhost:8082/v2/schemas/namespaces/myworld' \
--header "X-Cassandra-Token: $AUTH_TOKEN" \
--header 'Content-Type: application/json'
----

returns:

[source, plaintext]
----
{"data":{"name":"myworld"}}
----

For shorthand, `cURL` can use `-L` for `--location` and `-X` for `--request.`
// end::CheckNS[]

//== Drop namespaces or collections

// tag::DeleteNS[]
=== Dropping a namespace

Send a `DELETE` request to `/v2/schemas/namespaces/{namespace_name}` to delete
a namespace. All collections and documents will be deleted along with the
namespace.

[source, bash]
----
curl -L -X DELETE 'localhost:8082/v2/schemas/namespaces/myworld' \
--header "X-Cassandra-Token: $AUTH_TOKEN" \
--header 'Content-Type: application/json'
----
// end::DeleteNS[]

// LLP: leaving this item in, in anticipation of the addition to the API
// tag::deleteColl[]
//=== Dropping a collection

//Send a `DELETE` request to `/v2/schemas/namespaces/{namespace_name}/collections/{collection_name}`
//to delete a collection. All data will be deleted along with the collection schema.

//[source, bash]
//----
//curl --location \
//--request DELETE 'localhost:8082/v2/schemas/namespaces/myworld/collections/fitness' \
//--header "X-Cassandra-Token: $AUTH_TOKEN" \
//--header 'Content-Type: application/json'
//----
// end::deleteColl[]

// tag::updateColl[]
//== Update or replace a collection

//If you find a collection must be updated or replaced, send a `PUT` request to
//`/v2/schemas/namespaces/{namespace_name}/collections/{collection_name}` with
//the information to change:

//[source, bash]
//----
//curl --location
//--request PUT 'localhost:8082/v2/schemas/namespaces/myworld/collections/fitness'
//--header "X-Cassandra-Token: $AUTH_TOKEN"
//--header 'Content-Type: application/json'
// LLP: PUT IN INFO HERE
//----
// end::updateColl[]

== Interacting with data stored in collections

// tag::WriteBasicData[]
=== Writing documents

==== Specifying a collection name

First, let's add a document to a specified collection.
Send a `POST` request to `/v2/namespaces/{namespace_name}/collections/{collections_name}`
to add data to the collection `fitness`.
The data is passed in the JSON body.

[source,bash]
----
curl --location \
--request POST 'localhost:8082/v2/namespaces/myworld/collections/fitness' \
--header "X-Cassandra-Token: $AUTH_TOKEN" \
--header 'Content-Type: application/json' \
--data '{
  "id": "some-stuff",
  "other": "This is nonsensical stuff."
}'
----

returns:

[source, plaintext, subs="attributes+"]
----
{"documentId":"{docid}"}
----

Notice that the `document-id` returned is a UUID if not specified.
// end::WriteBasicData[]

==== Specifying collection name and document-id
Next, let's add a document to a specified collection, but specify the `document-id`.
Send a `PUT` request to
`/v2/namespaces/{namespace_name}/collections/{collections_name}/{document-id}`
to add data to the collection `Janet`.
The `document-id` can be any string.
The data is passed in the JSON body.

[source,bash]
----
curl -L -X PUT 'localhost:8082/v2/namespaces/myworld/collections/fitness/Janet' \
--header "X-Cassandra-Token: $AUTH_TOKEN" \
--header 'Content-Type: application/json' \
--data '{
  "firstname": "Janet",
  "lastname": "Doe",
  "email": "janet.doe@gmail.com",
  "favorite color": "grey"
}'
----

returns:

[source,plaintext]
----
{"documentId":"Janet"}
----

Note the difference between using `POST` and `PUT`. The `POST` request
is used to insert new documents when you want the system to auto-generate the
documentId. The `PUT` request is used to insert a new document when you want to
specify the documentId.

`PUT` requests can also be used to update an existing
document. Let's look at those examples, next.

// tag::WriteAdvData[]
==== Inserting a sub-document
You can also insert documents that have nested values, or sub-documents.
Send a `PUT` request to
`/v2/namespaces/{namespace_name}/collections/{collections_name}/{document-id}`
to add data to the existing collection.
The data is passed in the JSON body.

[source, bash, subs="attributes+"]
----
curl -L -X PUT 'localhost:8082/v2/namespaces/myworld/collections/fitness/Joey' \
--header "X-Cassandra-Token: $AUTH_TOKEN" \
--header 'Content-Type: application/json' \
--data '{
    "firstname": "Joey",
    "lastname": "Doe",
    "weights": {
      "type": "bench press",
      "weight": 150,
      "reps": 15
  }
}'
----

returns:

[source, plaintext]
----
{"documentId":"Joey"}
----
// end::WriteAdvData[]

////
==== Data types???
Need to add data types!!
////

// tag::ReadBasicData[]
=== Reading documents

==== Retrieving all documents
Let's check that the document was inserted. Send a `GET` request to
`/v2/namespaces/{namespace_name}/collections/{collections_name}` to retrieve
all the documents:

[source,bash]
----
curl --location \
--request GET 'localhost:8082/v2/namespaces/myworld/collections/fitness?page-size=3' \
--header "X-Cassandra-Token: $AUTH_TOKEN" \
--header 'Content-Type: application/json'
----

returns:

[source, plaintext, subs="attributes+"]
----
{
	"data":{
		"Joey":{
			"firstname":"Joey",
			"lastname":"Doe",
			"weights":{
				"reps":15,
				"type":"bench press",
				"weight":150
			}
		},
		"Janet":{
			"email":"janet.doe@gmail.com",
			"favorite color":"grey",
			"firstname":"Janet",
			"lastname":"Doe"
		},
		"{docid}":{
			"id":"some-stuff",
			"other":"This is nonsensical stuff."
		}
	}
}
----

The `page-size` parameter is included to get all the documents, rather than the
last inserted document.
The `pageState` is useful for pagination of the results in queries.

==== Retrieving a specified document
Let's check that the data was inserted for a particular document.
Send a `GET` request to `/v2/namespaces/{namespace_name}/collections/{collections_name}/{document-id}`
to retrieve the document:

[source, bash, subs="attributes+"]
----
curl -L \
-X GET 'localhost:8082/v2/namespaces/myworld/collections/fitness/{docid}' \
--header "X-Cassandra-Token: $AUTH_TOKEN" \
--header 'Content-Type: application/json'
----

returns:

[source, plaintext, subs="attributes+"]
----
{
	"documentId":"{docid}",
	"data":{
		"id":"some-stuff",
		"other":"This is nonsensical stuff."
	}
}
----

It is possible to get a value for a particular field in a document using one of
two methods, either a `where` clause or a `document-path`. These methods can
retrieve information from a document or a sub-document.

==== Retrieving a document using a where clause

Now let's search for a particular document using a `where` clause.
Send a `GET` request to
`/v2/namespaces/{namespace_name}/collections/{collections_name}?{where-clause}`
to get the same information:

[source, bash]
----
curl -L -X  GET 'localhost:8082/v2/namespaces/myworld/collections/fitness?where=\{"firstname":\{"$eq":"Janet"\}\}' \
--header "X-Cassandra-Token: $AUTH_TOKEN" \
--header 'Content-Type: application/json'
----

returns:

[source, plaintext]
----
{
	"data":{
		"Janet":{
			"email":"janet.doe@gmail.com",
			"favorite color":"grey",
			"firstname":"Janet",
			"lastname":"Doe"
		}
	}
}
----

Note that the `where` clause must be url encoded, so curly brackets are escaped
with `\` and spaces must be replaced with `%20`.
Also, the full document is returned, as opposed to the value of the field specified in the
`{document-path}` like the next command.
// end::ReadBasicData[]

// tag::ReadAdvData[]
You can also retrieve documents using a `WHERE` clause that searches sub-documents:

[source, bash]
----
curl -L -X  GET 'localhost:8082/v2/namespaces/myworld/collections/fitness?where=\{"weights.type":\{"$eq":"bench%20press"\}\}' \
--header "X-Cassandra-Token: $AUTH_TOKEN" \
--header 'Content-Type: application/json'
----

returns:

[source, plaintext]
----
{
	"data":{
		"Joey":{
			"firstname":"Joey",
			"lastname":"Doe",
			"weights":{
				"reps":15,
				"type":"bench press",
				"weight":150
			}
		}
	},
	"pageState":null
}
----

==== Retrieving a specific portion of a document with document-path

To find a particular value, send a `GET` request to
`/v2/namespaces/{namespace_name}/collections/{collections_name}/{document-id}/{document-path}`
to retrieve the type of weights Joey has done in his workout:

[source, bash]
----
curl -L -X  GET 'localhost:8082/v2/namespaces/myworld/collections/fitness/Joey/weights/type' \
--header "X-Cassandra-Token: $AUTH_TOKEN" \
--header 'Content-Type: application/json'
----

returns:

[source, plaintext]
----
{"documentId":"Joey","data":"bench press"}
----

In this case, the sub-document `weights` is the
`document-path` specified to retrieve that data about the `reps`, `type`, and
`weight`.

[source, bash]
----
curl --location --request GET 'localhost:8082/v2/namespaces/myworld/collections/fitness/Joey/weights' \
--header "X-Cassandra-Token: $AUTH_TOKEN" \
--header 'Content-Type: application/json'
----

returns:

[source, plaintext]
----
{
	"documentId":"Joey",
	"data":{
		"reps":15,
		"type":"bench press",
		"weight":150
	}
}
----
// end::ReadAdvData[]

// tag::UpdateBasicData[]
=== Update documents

Data changes, so often it is necessary to update an entire document.

==== Replace a document

Send a `PATCH` request to
`/v2/namespaces/{namespace_name}/collections/{collections_name}/{document-id}`
to replace data to the existing collection. All fields included will be changed.

[source,bash]
----
curl -L \
-X PATCH 'localhost:8082/v2/namespaces/myworld/collections/fitness/Janet' \
--header "X-Cassandra-Token: $AUTH_TOKEN" \
--header 'Content-Type: application/json' \
--data '{
    "firstname": "JanetLee",
    "lastname": "Doe"
}'
----

returns:

[source, plaintext]
----
{"documentId":"Janet"}
----

A `GET` request will show that the data has been replaced in the document:

[source,bash]
----
curl -L -X GET 'localhost:8082/v2/namespaces/myworld/collections/fitness/Janet' \
 --header "X-Cassandra-Token: $AUTH_TOKEN" \
 --header 'Content-Type: application/json'
----

returns:

[source, plaintext]
----
{
	"documentId":"Janet",
	"data":{
		"email":"janet.doe@gmail.com",
		"favorite color":"grey",
		"firstname":"JanetLee",
		"lastname":"Doe"
	}
}
----

NOTE: `PATCH` Updates are upserts. If the document doesn't exist, it will be created.
If it does exist, it will be updated with the new document data.

// end::UpdateBasicData[]

// tag::UpdateAdvData[]
==== Replace part of of a document or sub-document

It is also possible to update only part of a document. To partially update, send
a `PATCH` request to
 `/v2/namespaces/{namespace_name}/collections/{collections_name}/{document-id}/{document-path}`.
In this example, we want to change just the firstname of the document:

[source,bash]
----
curl -L \
-X PATCH 'localhost:8082/v2/namespaces/myworld/collections/fitness/Joey' \
--header "X-Cassandra-Token: $AUTH_TOKEN" \
--header 'Content-Type: application/json' \
--data '{
      "firstname": "Joseph"
}'
----

returns:

[source, plaintext]
----
{"documentId":"Joey"}
----

and a `GET` will show that only the `weights` has been changed.

[source, bash]
----
curl -L \
-X GET 'localhost:8082/v2/namespaces/myworld/collections/fitness/Joey' \
--header "X-Cassandra-Token: $AUTH_TOKEN" \
--header 'Content-Type: application/json'
----

returns:

[source, plaintext]
----
{
	"documentId":"Joey",
	"data":{
		"firstname":"Joseph",
		"lastname":"Doe",
		"weights":{
			"reps":15,
			"type":"bench press",
			"weight":150
		}
	}
}
----

To partially update a sub-document,  send a `PATCH` request to
 `/v2/namespaces/{namespace_name}/collections/{collections_name}/{document-id}/{document-path}`
 in the same manner as the last command, but including only sub-document
 information to change and the `document-path` of the sub-document. Include
 all fields that you wish to update.

[source,bash]
----
curl -L \
-X PATCH 'http://localhost:8082/v2/namespaces/myworld/collections/fitness/Joey/weights' \
--header "X-Cassandra-Token: $AUTH_TOKEN" \
--header 'Content-Type: application/json' \
--data '{
    "reps": 10,
    "type": "squat",
    "weight": 350
}'
----
// end::UpdateAdvData[]

// tag::DeleteBasicData[]
=== Delete documents
To delete a document, send a `DELETE` request to
`/v2/namespaces/{namespace_name}/collections/{collections_name}/{document-id}`.

[source,bash, subs="attributes+"]
----
curl -L \
-X DELETE 'http://localhost:8082/v2/namespaces/myworld/collections/fitness/{docid}' \
--header "X-Cassandra-Token: $AUTH_TOKEN" \
--header 'Content-Type: application/json'
----
// end::DeleteBasicData[]

// tag::DeleteAdvData[]
//To delete a document, based on a document path, send a `DELETE` request to
//`/v2/namespaces/{namespace_name}/collections/{collections_name}/{document-id}/{document-path}`.

//[source, bash]
//----
//curl -L -X  DELETE 'localhost:8082/v2/namespaces/myworld/collections/fitness?where=\{"id":\{"$eq":"some%2Dstuff"\}\}' \
//--header "X-Cassandra-Token: $AUTH_TOKEN" \
//--header 'Content-Type: application/json'
//----

//returns:

//[source, plaintext]
//----
//{
//	"data":{
//		"Janet":{
//			"email":"janet.doe@gmail.com",
//			"favorite color":"grey",
//			"firstname":"Janet",
//			"lastname":"Doe"
//		}
//	}
//}
//----
// end::DeleteAdvData[]
