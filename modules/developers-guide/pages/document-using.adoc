= Using the Stargate Document API

Stargate is a data gateway deployed between client applications and a database.
The Document API plugin that exposes CRUD access to data stored as unstructured JSON
documents in collections.

// tag::prereqsList[]
include::quickstart:partial$text/prereqs.adoc[]
// end::prereqsList[]

// tag::getDockerImage[]
include::quickstart:partial$bash/docker_pull.sh[]
// end::getDockerImage[]

// tag::startDocker[]
include::quickstart:partial$bash/docker_run.sh[]
// end::startDocker[]

// tag::swaggerUI[]
=== Swagger UI for the Document API

Once you have started the docker container, you can access the Document API
in a browser at `localhost:8082/swagger-ui`.
// end::swaggerUI[]

== Using the Auth API to generate an auth token

// tag::GenAuthToken[]
In order to use the Stargate Document API, an authorization token must be
generated to access the interface.

include::quickstart:partial$bash/gen_auth_token.sh[]
// end::GenAuthToken[]

// tag::UseAuthToken[]
include::quickstart:partial$bash/use_auth_token_rest_document.sh[]
// end::UseAuthToken[]

// tag::UsingPostman[]
== Using Postman

If you prefer, you can use Postman as a client interface for exploring the Document API
(https://www.postman.com/downloads/[download here]). You will need to add the
auth token to the header, similar to the `X-Cassandra-Token` shown below.
// LLP: NEED TO CREATE THIS FILE!!
//We've provided a
//https://github.com/stargate/docs/blob/master/modules/developers-guide/examples/stargate-document-api.postman_collection.json[Stargate Document API Postman Collection] that you
//can import in Postman to play with the examples shown in this walkthrough.
// end::UsingPostman[]

Now you're ready to use the Document API for CRUD operations.

// tag::CreateNS[]
== Creating or dropping a namespace

In order to use the Document API, you must create the namespace as a container
that will store collections, which in turn store documents.
Documents can themselves hold multiple documents.
Multiple collections are contained in a namespace, but a collection cannot be
contained in multiple namespaces.

Only namespaces need to specifically created. Collections are specified when a document
is inserted. A optional setting, `replicas`, defines
the number of data replicas the database will store for the namespace.
If no replica is defined, then for a namespace in a single datacenter cluster,
the default is 1, and for a multiple-datacenter cluster, the default is 3 for each
datacenter.

=== Creating a namespace

==== Simple namespace

Send a `POST` request to `/v2/schemas/namespaces`.
In this example we use `myworld` for the `name`, and no `replicas` setting, to default to 1.

[source,bash]
----
curl --location --request POST 'localhost:8082/v2/schemas/namespaces' \
--header "X-Cassandra-Token: $AUTH_TOKEN" \
--header 'Content-Type: application/json' \
--data '{
    "name": "myworld"
}'
----

The authorization token and the content type are passed with  `--header`. The
token must be identified as `X-Cassandra-Token` so that cluster recognizes the token
and its value.
The specified name and replicas for the namespace are passed as JSON
data using `--data`.
// end::CreateNS[]

// tag::CreateNSextra[]
==== Set replicas in simple namespace

To set the replicas, send a `POST` request to `/v2/schemas/namespaces`.
In this example we use `myworld` for the `name`,
and `2` for the number of data `replicas`.

[source,bash]
----
curl --location --request POST 'localhost:8082/v2/schemas/namespaces' \
--header "X-Cassandra-Token: $AUTH_TOKEN" \
--header 'Content-Type: application/json' \
--data '{
    "name": "myworld",
    "replicas": 2
}'
----

==== Namespace for multiple datacenters

For a multiple-datacenter cluster, a namespace is defined `datacenters`.
Send a `POST` request to `/v2/schemas/namespaces`.
In this example we use `myworld-dcs` for the `name`, the datacenters are `dc1` and `dc2`,
where `dc1` defaults to 3 replicas and `dc2` is set to 5 replicas.

[source,bash]
----
curl --location --request POST 'localhost:8082/v2/schemas/namespaces' \
--header "X-Cassandra-Token: $AUTH_TOKEN" \
--header 'Content-Type: application/json' \
--data '{
    "name": "myworld-dcs",
    "datacenters": [ {"name": "dc1"}, {"name": "dc2", "replicas": 5} ]
}'
----
// end::CreateNSextra[]

// tag::CheckNS[]
=== Checking namespace existence

To check if a namespaces exist, execute a
Document API query with `cURL` to find all the namespaces:

[source,bash]
----
curl -L -X GET 'localhost:8082/v2/schemas/namespaces' \
--header "X-Cassandra-Token: $AUTH_TOKEN" \
--header 'Content-Type: application/json'
----

returns:

[source, plaintext]
----
{"data":[
    {"name":"myworld"},
    {"name":"system_distributed"},
    {"name":"system"},
    {"name":"data_endpoint_auth"},
    {"name":"system_schema"},
    {"name":"stargate_system"},
    {"name":"system_auth"},
    {"name":"system_traces"}
  ]
}
----

To get a particular namespace, specify the namespace in the URL:

[source,bash]
----
curl -X GET 'localhost:8082/v2/schemas/namespaces/myworld' \
--header "X-Cassandra-Token: $AUTH_TOKEN" \
--header 'Content-Type: application/json'
----

returns:

[source, plaintext]
----
{"data":{"name":"myworld"}}
----

For shorthand, `cURL` can use `-L` for `--location` and `-X` for `--request.`
// end::CheckNS[]

//== Drop namespaces or collections

// tag::deleteNS[]
=== Dropping a namespace

Send a `DELETE` request to `/v2/schemas/namespaces/{namespace_name}` to delete
a namespace. All collections and documents will be deleted along with the
namespace.

[source, bash]
----
curl -L -X DELETE 'localhost:8082/v2/schemas/namespaces/myworld' \
--header "X-Cassandra-Token: $AUTH_TOKEN" \
--header 'Content-Type: application/json'
----
// end::deleteNS[]

// LLP: leaving this item in, in anticipation of the addition to the API
// tag::deleteColl[]
//=== Dropping a collection

//Send a `DELETE` request to `/v2/schemas/namespaces/{namespace_name}/collections/{collection_name}`
//to delete a collection. All data will be deleted along with the collection schema.

//[source, bash]
//----
//curl --location \
//--request DELETE 'localhost:8082/v2/schemas/namespaces/myworld/collections/fitness' \
//--header "X-Cassandra-Token: $AUTH_TOKEN" \
//--header 'Content-Type: application/json'
//----
// end::deleteColl[]

// tag::updateColl[]
//== Update or replace a collection

//If you find a collection must be updated or replaced, send a `PUT` request to
//`/v2/schemas/namespaces/{namespace_name}/collections/{collection_name}` with
//the information to change:

//[source, bash]
//----
//curl --location
//--request PUT 'localhost:8082/v2/schemas/namespaces/myworld/collections/fitness'
//--header "X-Cassandra-Token: $AUTH_TOKEN"
//--header 'Content-Type: application/json'
// LLP: PUT IN INFO HERE
//----
// end::updateColl[]

== Interacting with data stored in collections

// tag::WriteBasicData[]
=== Writing documents

==== Specifying a collection name
First, let's add a document to a specified collection.
Send a `POST` request to `/v2/namespaces/{namespace_name}/collections/{collections_name}`
to add data to the collection `fitness`.
The data is passed in the JSON body.

[source,bash]
----
curl --location \
--request POST 'localhost:8082/v2/namespaces/myworld/collections/fitness' \
--header "X-Cassandra-Token: $AUTH_TOKEN" \
--header 'Content-Type: application/json' \
--data '{
    "firstname": "Janet",
    "lastname": "Doe",
    "email": "janet.doe@gmail.com",
    "favorite color": "grey"
}'
----

returns:

[source,plaintext]
----
{"documentId":"1c338f67-4bff-443d-b2d2-f21d8291bdb8"}
----

Notice that the `document-id` returned is a UUID if not specified.
// end::WriteBasicData[]

// tag::WriteAdvData[]
==== Specifying collection name and document-id
Next, let's add a document to a specified collection, but specify the `document-id`.
Send a `PUT` request to
`/v2/namespaces/{namespace_name}/collections/{collections_name}/{document-id}`
to add data to the collection `some-stuff`.
The `document-id` can be any string.
The data is passed in the JSON body.

[source,bash]
----
curl -L -X PUT 'localhost:8082/v2/namespaces/myworld/collections/fitness/some-stuff' \
--header "X-Cassandra-Token: $AUTH_TOKEN" \
--header 'Content-Type: application/json' \
--data '{
    "id": "Some stuff",
    "thestuff": "This is a nonsensical message."
}'
----

returns:

[source,plaintext]
----
{"documentId":"some-stuff"}
----

Note the difference between using `POST` and `PUT`. `POST` is used to insert
documents to an empty collection. `PUT` is used to add a document to an existing
collection.

==== Inserting a sub-document
You can also insert documents that have nested values, or sub-documents.
Send a `PUT` request to
`/v2/namespaces/{namespace_name}/collections/{collections_name}/{document-id}`
to add data to the existing collection.
The data is passed in the JSON body.

[source,bash]
----
curl -L -X PUT 'localhost:8082/v2/namespaces/myworld/collections/fitness/350041bd-5e41-421b-9b3b-f021921851ce' \
--header "X-Cassandra-Token: $AUTH_TOKEN" \
--header 'Content-Type: application/json' \
--data '{
    "firstname": "Joey",
    "lastname": "Doe",
    "weights": {
      "type": "bench press",
      "weight": 150,
      "reps": 15
  }
}'
----

returns:

[source, plaintext]
----
{"documentId":"350041bd-5e41-421b-9b3b-f021921851ce"}
----
// end::WriteAdvData[]


////
==== Data types???
Need to add data types!!
////

// tag::ReadBasicData[]
=== Reading documents

==== Retrieving all documents
Let's check that the document was inserted. Send a `GET` request to
`/v2/namespaces/{namespace_name}/collections/{collections_name}` to retrieve
all the documents:

[source,bash]
----
curl --location \
--request GET 'localhost:8082/v2/namespaces/myworld/collections/fitness?page-size=3' \
--header "X-Cassandra-Token: $AUTH_TOKEN" \
--header 'Content-Type: application/json'
----

returns:

[source, plaintext]
----
{"data":
{
"some-stuff":{"id":"Some stuff","thestuff":"This is a nonsensical message."},
"1c338f67-4bff-443d-b2d2-f21d8291bdb8":{
  "email":"janet.doe@gmail.com","favorite color":"grey","firstname":"Janet","lastname":"Doe"},
"350041bd-5e41-421b-9b3b-f021921851ce":{
  "firstname":"Joey","lastname":"Doe","weights":{"reps":15,"type":"bench press","weight":150}},
"pageState":"JDAyMGE0MGU5LTFiYjctNGUwNS05YmRlLTcyYzg4Y2U1NzExYxv/VVVVVVVVVVQIbGFzdG5hbWX/VVVVVVVVVVXwf///6fB////6"
}
----

The `page-size` parameter is included to get all the documents, rather than the
last inserted document.
The `pageState` is useful for pagination of the results in queries.

==== Retrieving a specified document
Let's check that the data was inserted for a particular document.
Send a `GET` request to `/v2/namespaces/{namespace_name}/collections/{collections_name}/{document-id}`
to retrieve the document:

[source, bash]
----
curl -L \
-X GET 'localhost:8082/v2/namespaces/myworld/collections/fitness/020a40e9-1bb7-4e05-9bde-72c88ce5711c' \
--header "X-Cassandra-Token: $AUTH_TOKEN" \
--header 'accept: application/json' \
--header 'Content-Type: application/json'
----

returns:

[source, plaintext]
----
{"documentId":"020a40e9-1bb7-4e05-9bde-72c88ce5711c",
"data":{
  "email":"janet.doe@gmail.com",
  "favorite color":"grey",
  "firstname":"Janet",
  "lastname":"Doe"
 }
}
----

It is possible to get a value for a particular field in a document using one of
two methods, either a `where` clause or a `document-path`. These methods can
retrieve information from a document or a sub-document.

==== Retrieving a document using a where clause
Now let's search for a particular document using a `where` clause.
Send a `GET` request to
`/v2/namespaces/{namespace_name}/collections/{collections_name}?{where-clause}`
to get the same information:

[source, bash]
----
curl -L -X  GET 'localhost:8082/v2/namespaces/myworld/collections/fitness?where=\{"weights.type":\{"$eq":"bench%20press"\}\}' \
--header "X-Cassandra-Token: $AUTH_TOKEN" \
--header 'Content-Type: application/json'
----

 returns:

[source, plaintext]
----
{"data":{"350041bd-5e41-421b-9b3b-f021921851ce":{
  "firstname":"Joey",
  "lastname":"Doe",
  "weights":{
    "reps":15,
    "type":"bench press",
    "weight":150
  }
}
},
"pageState":null}
----
Note that the `where` clause must be url encoded, so spaces are replaced with `%20`,
and curly brackets are escaped with `\`.
Also, the full document is returned, as opposed to the value of the field specified in the
`{document-path}` like the next command.
// end::ReadBasicData[]

// tag::ReadAdvData[]
==== Retrieving a specific portion of a document with document-path

To find a particular value, send a `GET` request to
`/v2/namespaces/{namespace_name}/collections/{collections_name}/{document-id}/{document-path}`
to retrieve the type of weights Joey has done in his workout:

[source, bash]
----
curl -L -X  GET 'localhost:8082/v2/namespaces/myworld/collections/fitness/350041bd-5e41-421b-9b3b-f021921851ce/weights/type' \
--header "X-Cassandra-Token: $AUTH_TOKEN" \
--header 'Content-Type: application/json'
----

returns:

[source, plaintext]
----
{"documentId":"350041bd-5e41-421b-9b3b-f021921851ce","data":"bench press"}
----

In this case, the sub-document `weights` that has a field `type` is the
`document-path` specified to retrieve that data that `bench press` is stored there.

[source, bash]
----
curl --location --request GET 'localhost:8082/v2/namespaces/myworld/collections/fitness/350041bd-5e41-421b-9b3b-f021921851ce/weights' \
--header "X-Cassandra-Token: $AUTH_TOKEN" \
--header 'Content-Type: application/json'
----

returns:

[source, plaintext]
----
{"documentId":"350041bd-5e41-421b-9b3b-f021921851ce",
 "data":{
   "reps":15,
   "type":"bench press",
   "weight":150
  }
}
----
// end::ReadAdvData[]

// tag::UpdateBasicData[]
=== Update documents

Data changes, so often it is necessary to update an entire document.

==== Replace a document

Send a `PATCH` request to
`/v2/namespaces/{namespace_name}/collections/{collections_name}/{document-id}`
to replace data to the existing collection. All fields included will be changed.

[source,bash]
----
curl -L \
-X PATCH 'localhost:8082/v2/namespaces/myworld/collections/fitness/350041bd-5e41-421b-9b3b-f021921851ce' \
--header "X-Cassandra-Token: $AUTH_TOKEN" \
--header 'Content-Type: application/json' \
--data '{
    "firstname": "Joey",
    "lastname": "Doe",
    "weights": {
      "type": "squat",
      "weight": 350,
      "reps": 10
  }
}'
----

returns:

[source, plaintext]
----
{"documentId":"350041bd-5e41-421b-9b3b-f021921851ce"}
----

A `GET` request will show that the data has been replaced in the document:

[source,bash]
----
curl -L -X GET 'localhost:8082/v2/namespaces/myworld/collections/fitness/350041bd-5e41-421b-9b3b-f021921851ce' \
 --header "X-Cassandra-Token: $AUTH_TOKEN" \
 --header 'Content-Type: application/json'
----

returns:

[source, plaintext]
----
{"documentId":"350041bd-5e41-421b-9b3b-f021921851ce",
 "data":{
   "firstname":"Joey",
   "lastname":"Doe",
   "weights":{
     "reps":10,
     "type":"squat",
     "weight":350
    }
  }
}
----

NOTE: `PATCH` Updates are upserts. If the document doesn't exist, it will be created.
If it does exist, it will be updated with the new document data.

// end::UpdateBasicData[]

// tag::UpdateAdvData[]
==== Replace part of of a document or sub-document

It is also possible to update only part of a document. To partially update, send
a `PATCH` request to
 `/v2/namespaces/{namespace_name}/collections/{collections_name}/{document-id}`.
In this example, we want to change just the first name of the document:

[source,bash]
----
curl -L \
-X PATCH 'localhost:8082/v2/namespaces/myworld/collections/fitness/350041bd-5e41-421b-9b3b-f021921851ce' \
--header "X-Cassandra-Token: $AUTH_TOKEN" \
--header 'Content-Type: application/json' \
-d '{"firstname": "Jane"}'
----

returns:

[source, plaintext]
----
{"documentId":"350041bd-5e41-421b-9b3b-f021921851ce"}
----

and a `GET` will show that only the `firstname` has been changed.

To partially update a sub-document,  send a `PATCH` request to
 `/v2/namespaces/{namespace_name}/collections/{collections_name}/{document-id}/{document-path}`
 in the same manner as the last command, but including only sub-document
 information to change and the `document-path` of the sub-document. Include
 all fields that you wish to update.

[source,bash]
----
curl -L \
-X PATCH 'http://localhost:8082/v2/namespaces/myworld/collections/fitness/350041bd-5e41-421b-9b3b-f021921851ce/weights' \
--header "X-Cassandra-Token: $AUTH_TOKEN" \
--header 'Content-Type: application/json' \
--data '{
    "reps": 20,
    "weight": 250
}'
----
// end::UpdateAdvData[]

// tag::DeleteBasicData[]
=== Delete documents
To delete a document, send a `DELETE` request to
`/v2/namespaces/{namespace_name}/collections/{collections_name}/{document-id}`.

[source,bash]
----
curl -L \
-X DELETE 'http://localhost:8082/v2/namespaces/myworld/collections/fitness/some-stuff' \
--header "X-Cassandra-Token: $AUTH_TOKEN" \
--header 'Content-Type: application/json'
----
// end::DeleteBasicData[]

// tag::DeleteAdvData[]
To delete a document, based on a document path, send a `DELETE` request to
`/v2/namespaces/{namespace_name}/collections/{collections_name}/{document-id}/{document-path}`.
// end::DeleteAdvData[]
