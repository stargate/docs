
= Apollo data federation for GraphQL schema-first

Data federation is the creation of a virtual database that aggregates data from
distributed sources, giving them a common data model.
It is an approach to data integration that provides a single source of data for
front-end applications.
It also gives backend developers flexibility in design and service isolation.

To get the most out of GraphQL, your organization should expose a single data
graph that provides a unified interface for querying any combination of your
backing data sources.
However, it can be challenging to represent an enterprise-scale data graph with
a single, monolithic GraphQL server.

To remedy this, you can divide your graph's implementation across multiple
composable services with Apollo Federation.
Unlike other distributed GraphQL architectures (such as schema stitching),
Apollo Federation uses a declarative programming model that enables each subgraph
to implement only the part of your composed supergraph that it's responsible for.

An Apollo Federation architecture consists of:

* A collection of subgraphs (usually represented by different back-end services)
that each define a distinct GraphQL schema
* A gateway that composes the subgraphs into a federated data graph and executes
queries across multiple subgraphs

== GraphQL schema

To achieve data federation, schemas need to be created and annotated to indicate how
ownership is distributed.
Letâ€™s look at an example with three core entities:

Book: In a library, books are stored.
The Book type uses a title and ISBN to uniquely identify each Book object, while
also storing author information.

Reader: Readers read books and write reviews.
Each Reader is uniquely identified by a name and user_id, while also storing
birthdate, email addresses, street addresses, and reviews that a read has written.
Each review consists of the book title, comment, rating, and review date.

Order: When a reader checks out books from the library, a record of the
checkout_id, reader, and the books checked out are stored, uniquely identified
by the checkout_id.

These three domains could be owned by three separate engineering teams responsible for
their own data sources, business logic, and corresponding microservices.
In an unfederated implementation, we would have to have this simple schema and
the associated resolvers owned and implemented by a single team.

=== Stargate GraphQL schema

In this example, `Book` and `Reader` schema are supplied from a Stargate instance
as the first data source,and the schema is described in the
xref:graphql-first-using.adoc[GraphQL schema-first] section.

=== Javascript Apollo server schema
For `Order`, a simple Javascript, `orders.js` will be used to define the `Order`
schema, supply some resolvers, insert some data, and start an Apollo server as
the second data source.

[tabs]
====
Orders.js::
+
--
[source,shell]
----
include::example$graphql/1orders.js[]
----
--
====

Let's break down this script.
First, set up the script to require `apollo server` and `apollo federation`.
Set the port for the server to `4001`.

[tabs]
====
Orders setup::
+
--
[source,shell]
----
include::example$graphql/1orders-1.js[]
----
--
====

Next, we need to load the schema for this server.
The schema consists of the object type `Order`, extensions of the object types
`Book` and `Reader` gathered from the Stargate instance, queries and mutations
required to insert data and make queries.

[tabs]
====
Orders schema::
+
--
[source,shell]
----
include::example$graphql/1orders-2.js[]
----
--
====

In order to fetch field values from the objects that belong to another service,
an `extension` of that object must be included in the Apollo server.
Two directives are used in this example, `@key` and `@external` that pertain to
data federation.
The `@key` directive defines a combination of fields that uniquely identify and
are used to fetch an object or interface.
The `@external` directive marks a field as owned by another service.

In this example, for the `Book` object type, the fields `title` and `isbn` are
defined the the `@key` directive as the fields that are required to uniquely identify
a specific book and fetch the requested information from the object.
The `@external` directive further marks the same fields are owned by the Stargate
service, not the Apollo server.
The `Reader` object type has a similar extension defined.

Now let's define the resolvers that this script will use.
A resolver is a function that's responsible for populating the data for a single
field in your schema.
Stargate resolves objects based on the schema supplied, but the Javascript server
requires resolver definition.

[tabs]
====
Orders resolvers::
+
--
[source,shell]
----
include::example$graphql/1orders-3.js[]
----
--
====

Finally, a server is started, building federated schema, listening on port 4001.
Data is provided on the orders that are inserted into the service.

[tabs]
====
Orders server::
+
--
[source,shell]
----
include::example$graphql/1orders-4.js[]
----
--
====

== Installing Apollo gateway

Let's look at a simple Javascript that runs the Apollo gateway:

[tabs]
====
gateway.js::
+
--
[source,shell]
----
include::example$graphql/1gateway.js[]
----
--
====

Let's break down this script.

[tabs]
====
Gateway1::
+
--
[source,shell]
----
include::example$graphql/1gateway-1.js[]
----
--
Gateway2::
+
--
[source,shell]
----
include::example$graphql/1gateway-2.js[]
----
--
Gateway3::
+
--
[source,shell]
----
include::example$graphql/1gateway-3.js[]
----
--
====

In Gateway1, an Apollo server and Apollo gateway are defined as required.
In order for the gateway to access the Stargate data source, a token is required.
That token is specified as `stargateIntrospectionToken`.

In Gateway2, a `serviceList` that defines the data sources lists the Stargate
instance and the Javascript Apollo server that are described above.
It builds the services based on logic tied to the name of the data source,
`library`.
Note that if more data sources are specified, you'll need to change the logic
that specifies which service is used for queries and mutations.

An experimental flag is set to allow GraphQL Playground to display the query
plan for the federated service.

In Gateway3, a new Apollo server, designated as a gateway is started.
There are some settings currently set to false; the code gives an explanation.
If the fetched data is from the Stargate instance, the token must be passed
in the header of the request as `x-cassandra-token`.

== Federated queries

Now that we have two subgraphs supplied from two different data sources,
and a gateway running, we can explore how data from all data sources can be
returned in a query.

For example, if I want to discover all the books that were checked out at the
same time, and get all the book data, I can use this query in GraphQL Playground,
pointed to the URL where the gateway is running, or `localhost:4000` in this case:

[tabs]
====
Get a checkout order by ID::
+
--
[source,shell]
----
include::example$graphql/1fetchOrderById.graphql[]
----
--
Result::
+
--
[source,shell]
----
include::example$result/gql_1fetchOrderById.result[]
----
--
====

While the resulting return seems unremarkable, think about the result for a moment.
The Apollo server returning an order did supply the reader `name` and `user_id`, but
the `email` and `address` information is fetched from the Stargate instance.
Likewise, the Stargate instance is also supplying the author information for
the books returned in the `order` query.
Thus, the federated supergraph of Order, Book, and Reader, along with the
resolvers in the Apollo server, are fetching data from two different servers!
That is a very valuable feature, especially for application developers who need
to fetch and use data from data sources that they do not control.

=== Examples of queries

Use the queries I have created in data_federation.adoc...
